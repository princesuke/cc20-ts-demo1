import { $ZodRegistry, toJSONSchema, $ZodType } from "zod/v4/core";
import { convertSchemaToOpenAPISchemaVersion } from "./openapi.js";
const getSchemaId = (id, io) => {
  return io === "input" ? `${id}Input` : id;
};
const getReferenceUri = (id, io) => {
  return `#/components/schemas/${getSchemaId(id, io)}`;
};
function isZodDate(entity) {
  return entity instanceof $ZodType && entity._zod.def.type === "date";
}
function isZodUndefined(entity) {
  return entity instanceof $ZodType && entity._zod.def.type === "undefined";
}
const getOverride = (ctx, io, registry) => {
  let meta = registry.get(ctx.zodSchema);
  if (!meta) {
    const schemaMeta = ctx.zodSchema.meta();
    if (schemaMeta) {
      meta = schemaMeta;
    }
  }
  if (meta) {
    if (typeof meta.description === "string") {
      ctx.jsonSchema.description = meta.description;
    }
    if (meta.example) {
      ctx.jsonSchema.example = meta.example;
    }
  }
  if (io === "input") {
    return;
  }
  if (isZodDate(ctx.zodSchema)) {
    ctx.jsonSchema.type = "string";
    ctx.jsonSchema.format = "date-time";
  }
  if (isZodUndefined(ctx.zodSchema)) {
    ctx.jsonSchema.type = "null";
  }
};
const zodJSONSchemaTarget = "draft-2020-12";
const zodSchemaToJson = (zodSchema, registry, io, openAPISchemaVersion) => {
  const schemaRegistryEntry = registry.get(zodSchema);
  if (schemaRegistryEntry?.id) {
    return { $ref: getReferenceUri(schemaRegistryEntry.id, io) };
  }
  const tempID = "GEN";
  const tempRegistry = new $ZodRegistry();
  tempRegistry.add(zodSchema, { id: tempID });
  const {
    schemas: { [tempID]: result }
  } = toJSONSchema(tempRegistry, {
    target: zodJSONSchemaTarget,
    metadata: registry,
    io,
    unrepresentable: "any",
    cycles: "ref",
    reused: "inline",
    /**
     * The uri option only allows customizing the base path of the `$ref`, and it automatically appends a path to it.
     * As a workaround, we set a placeholder that looks something like this:
     *
     * |       marker          | always added by zod | meta.id |
     * |__SCHEMA__PLACEHOLDER__|      #/$defs/       | User    |
     *
     * @example `__SCHEMA__PLACEHOLDER__#/$defs/User"`
     * @example `__SCHEMA__PLACEHOLDER__#/$defs/Group"`
     *
     * @see jsonSchemaReplaceRef
     * @see https://github.com/colinhacks/zod/issues/4750
     */
    uri: () => "__SCHEMA__PLACEHOLDER__",
    override: (ctx) => getOverride(ctx, io, registry)
  });
  const jsonSchemaReplaceRef = JSON.stringify(result).replaceAll(
    /"__SCHEMA__PLACEHOLDER__#\/\$defs\/(.+?)"/g,
    (_, id) => `"${getReferenceUri(id, io)}"`
  );
  const jsonSchemaWithRef = JSON.parse(jsonSchemaReplaceRef);
  return convertSchemaToOpenAPISchemaVersion(jsonSchemaWithRef, {
    openAPISchemaVersion
  });
};
const zodRegistryToJson = (registry, io, openAPISchemaVersion) => {
  const result = toJSONSchema(registry, {
    target: zodJSONSchemaTarget,
    io,
    unrepresentable: "any",
    cycles: "ref",
    reused: "inline",
    uri: (id) => getReferenceUri(id, io),
    override: (ctx) => getOverride(ctx, io, registry)
  }).schemas;
  const jsonSchemas = {};
  for (const id in result) {
    jsonSchemas[getSchemaId(id, io)] = convertSchemaToOpenAPISchemaVersion(
      result[id],
      { openAPISchemaVersion }
    );
  }
  return jsonSchemas;
};
const refPropertyValueMatch = /^#\/components\//;
function collectRefs(obj, refs = /* @__PURE__ */ new Set()) {
  if (obj && typeof obj === "object") {
    for (const [key, value] of Object.entries(obj)) {
      if (key === "$ref" && typeof value === "string") {
        refs.add(value.replace(refPropertyValueMatch, ""));
      } else {
        collectRefs(value, refs);
      }
    }
  }
  return refs;
}
function removeUnusedRefs(spec) {
  const usedRefs = collectRefs(spec.paths);
  const components = spec.components;
  if (!components) {
    return spec;
  }
  for (const section of Object.keys(components)) {
    const items = components[section];
    if (!items) {
      continue;
    }
    for (const key of Object.keys(items)) {
      if (![...usedRefs].some((r) => r.startsWith(`${section}/${key}`))) {
        delete items[key];
      }
    }
  }
  return spec;
}
export {
  removeUnusedRefs,
  zodRegistryToJson,
  zodSchemaToJson
};
//# sourceMappingURL=zod-to-json.js.map
