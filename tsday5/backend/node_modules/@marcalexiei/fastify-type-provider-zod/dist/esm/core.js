import { globalRegistry, safeParse, $ZodType } from "zod/v4/core";
import { ResponseSerializationError, createValidationError, InvalidSchemaError } from "./errors.js";
import { getOpenAPISchemaVersion } from "./openapi.js";
import { zodSchemaToJson, zodRegistryToJson, removeUnusedRefs } from "./zod-to-json.js";
const defaultSkipList = [
  "/documentation/",
  "/documentation/initOAuth",
  "/documentation/json",
  "/documentation/uiConfig",
  "/documentation/yaml",
  "/documentation/*",
  "/documentation/static/*"
];
const createJsonSchemaTransform = ({
  skipList = defaultSkipList,
  schemaRegistry = globalRegistry
}) => {
  return (transformData) => {
    if ("swaggerObject" in transformData) {
      throw new Error(
        "createJsonSchemaTransform - OpenAPI 2.0 is not supported"
      );
    }
    const { schema, url } = transformData;
    if (!schema) {
      return { schema, url };
    }
    const { response, headers, querystring, body, params, hide, ...rest } = schema;
    const transformed = {};
    if (skipList.includes(url) || hide) {
      transformed.hide = true;
      return { schema: transformed, url };
    }
    const zodSchemas = {
      headers,
      querystring,
      body,
      params
    };
    const openAPISchemaVersion = getOpenAPISchemaVersion(transformData);
    for (const prop in zodSchemas) {
      const zodSchema = zodSchemas[prop];
      if (zodSchema) {
        transformed[prop] = zodSchemaToJson(
          zodSchema,
          schemaRegistry,
          "input",
          openAPISchemaVersion
        );
      }
    }
    if (response) {
      transformed.response = {};
      for (const prop in response) {
        const zodSchema = resolveSchema(response[prop]);
        transformed.response[prop] = zodSchemaToJson(
          zodSchema,
          schemaRegistry,
          "output",
          openAPISchemaVersion
        );
      }
    }
    for (const prop in rest) {
      const meta = rest[prop];
      if (meta) {
        transformed[prop] = meta;
      }
    }
    return { schema: transformed, url };
  };
};
const jsonSchemaTransform = createJsonSchemaTransform({});
const createJsonSchemaTransformObject = (options) => {
  const { schemaRegistry = globalRegistry } = options ?? {};
  return (documentObject) => {
    if ("swaggerObject" in documentObject) {
      throw new Error(
        "createJsonSchemaTransformObject - OpenAPI 2.0 is not supported"
      );
    }
    const openAPISchemaVersion = getOpenAPISchemaVersion(documentObject);
    const inputSchemas = zodRegistryToJson(
      schemaRegistry,
      "input",
      openAPISchemaVersion
    );
    const outputSchemas = zodRegistryToJson(
      schemaRegistry,
      "output",
      openAPISchemaVersion
    );
    for (const key in outputSchemas) {
      if (inputSchemas[key]) {
        throw new Error(
          `Collision detected for schema "${key}". The is already an input schema with the same name.`
        );
      }
    }
    return removeUnusedRefs({
      ...documentObject.openapiObject,
      components: {
        ...documentObject.openapiObject.components,
        schemas: {
          ...documentObject.openapiObject.components?.schemas,
          ...inputSchemas,
          ...outputSchemas
        }
      }
    });
  };
};
const jsonSchemaTransformObject = createJsonSchemaTransformObject({});
const validatorCompiler = ({
  schema: maybeSchema
}) => {
  return (data) => {
    const schema = resolveSchema(maybeSchema);
    const result = safeParse(schema, data);
    if (result.error) {
      return { error: createValidationError(result.error) };
    }
    return { value: result.data };
  };
};
function resolveSchema(maybeSchema) {
  if (maybeSchema instanceof $ZodType) {
    return maybeSchema;
  }
  throw new InvalidSchemaError(JSON.stringify(maybeSchema));
}
const createSerializerCompiler = (options) => {
  return ({ schema: maybeSchema, method, url }) => {
    return (data) => {
      const schema = resolveSchema(maybeSchema);
      const result = safeParse(schema, data);
      if (result.error) {
        throw new ResponseSerializationError(method, url, {
          cause: result.error
        });
      }
      return JSON.stringify(result.data, options?.replacer);
    };
  };
};
const serializerCompiler = createSerializerCompiler();
export {
  createJsonSchemaTransform,
  createJsonSchemaTransformObject,
  createSerializerCompiler,
  jsonSchemaTransform,
  jsonSchemaTransformObject,
  serializerCompiler,
  validatorCompiler
};
//# sourceMappingURL=core.js.map
