"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const getOpenAPISchemaVersion = (documentObject) => {
  const openapiVersion = documentObject.openapiObject.openapi;
  if (openapiVersion?.startsWith("3.1")) {
    return "3.1";
  }
  if (openapiVersion?.startsWith("3.0")) {
    return "3.0";
  }
  throw new Error("Unsupported OpenAPI document object");
};
const convertSchemaToOpenAPISchemaVersion = (jsonSchema, options) => {
  const { openAPISchemaVersion } = options;
  const clone = { ...jsonSchema };
  if (openAPISchemaVersion === "3.1") {
    delete clone.$id;
    delete clone.$schema;
    return clone;
  }
  if (clone.oneOf?.some((s) => s.type === "null")) {
    const notNullableItems = clone.oneOf.filter((s) => s.type !== "null");
    clone.nullable = true;
    clone.oneOf = notNullableItems;
  }
  if (clone.anyOf?.some((s) => s.type === "null")) {
    const notNullableItems = clone.anyOf.filter((s) => s.type !== "null");
    if (clone.anyOf.length === 2) {
      Object.assign(
        clone,
        // If length is 2 it means there is only one element besides `null`
        notNullableItems[0],
        { nullable: true }
      );
      delete clone.anyOf;
    } else {
      clone.nullable = true;
      clone.anyOf = notNullableItems;
    }
  }
  if (Array.isArray(clone.prefixItems)) {
    const tuple = clone.prefixItems;
    clone.minItems ??= tuple.length;
    clone.maxItems ??= tuple.length;
    clone.items = {
      oneOf: tuple.map(
        (it) => convertSchemaToOpenAPISchemaVersion(it, {
          openAPISchemaVersion
        })
      )
    };
    delete clone.prefixItems;
  }
  if ("const" in clone && clone.const !== void 0) {
    clone.enum = [clone.const];
    delete clone.const;
  }
  if (typeof clone.exclusiveMinimum === "number") {
    clone.minimum = clone.exclusiveMinimum;
    delete clone.exclusiveMinimum;
  }
  if (typeof clone.exclusiveMaximum === "number") {
    clone.maximum = clone.exclusiveMaximum;
    delete clone.exclusiveMaximum;
  }
  for (const key of [
    "id",
    "$schema",
    "$id",
    "unevaluatedProperties",
    "dependentSchemas",
    "patternProperties",
    "propertyNames",
    "contentEncoding",
    "contentMediaType"
  ]) {
    delete clone[key];
  }
  const recursive = (v) => {
    if (Array.isArray(v)) {
      return v.map(
        (it) => convertSchemaToOpenAPISchemaVersion(it, {
          openAPISchemaVersion
        })
      );
    }
    return convertSchemaToOpenAPISchemaVersion(v, { openAPISchemaVersion });
  };
  if (clone.properties) {
    for (const [k, v] of Object.entries(clone.properties)) {
      clone.properties[k] = convertSchemaToOpenAPISchemaVersion(
        v,
        { openAPISchemaVersion }
      );
    }
  }
  if (clone.items && !Array.isArray(clone.items)) {
    clone.items = recursive(clone.items);
  }
  for (const key of [
    "allOf",
    "anyOf",
    "oneOf",
    "not",
    "then",
    "else",
    "if",
    "contains"
  ]) {
    if (clone[key]) {
      clone[key] = recursive(clone[key]);
    }
  }
  return clone;
};
exports.convertSchemaToOpenAPISchemaVersion = convertSchemaToOpenAPISchemaVersion;
exports.getOpenAPISchemaVersion = getOpenAPISchemaVersion;
//# sourceMappingURL=openapi.cjs.map
