{"version":3,"file":"zod-to-json.cjs","sources":["../../src/zod-to-json.ts"],"sourcesContent":["import type { $ZodDate, $ZodUndefined, JSONSchema } from 'zod/v4/core';\nimport { $ZodRegistry, $ZodType, toJSONSchema } from 'zod/v4/core';\nimport {\n  convertSchemaToOpenAPISchemaVersion,\n  type OpenAPISchemaVersion,\n} from './openapi.ts';\n\nconst getSchemaId = (id: string, io: 'input' | 'output') => {\n  return io === 'input' ? `${id}Input` : id;\n};\n\nconst getReferenceUri = (id: string, io: 'input' | 'output') => {\n  return `#/components/schemas/${getSchemaId(id, io)}`;\n};\n\nfunction isZodDate(entity: unknown): entity is $ZodDate {\n  return entity instanceof $ZodType && entity._zod.def.type === 'date';\n}\n\nfunction isZodUndefined(entity: unknown): entity is $ZodUndefined {\n  return entity instanceof $ZodType && entity._zod.def.type === 'undefined';\n}\n\nconst getOverride = (\n  ctx: {\n    zodSchema: $ZodType;\n    jsonSchema: JSONSchema.BaseSchema;\n  },\n  io: 'input' | 'output',\n  registry: $ZodRegistry,\n) => {\n  // Extract metadata from the specified registry.\n  // The `.meta()` method adds the element to the global registry.\n  // Note: If a custom registry is used, any properties registered via `.meta()`\n  // will be lost when `.register()` is called.\n  let meta = registry.get(ctx.zodSchema) as Record<string, unknown>;\n\n  // You can still inlining metadata in the schema that are not included in the registry,\n  // e.g., a query param\n  if (!meta) {\n    // @ts-expect-error\n    const schemaMeta = ctx.zodSchema.meta() as Record<string, unknown>;\n    if (schemaMeta) {\n      meta = schemaMeta;\n    }\n  }\n\n  if (meta) {\n    if (typeof meta.description === 'string') {\n      ctx.jsonSchema.description = meta.description;\n    }\n    if (meta.example) {\n      ctx.jsonSchema.example = meta.example;\n    }\n  }\n\n  if (io === 'input') {\n    return;\n  }\n\n  // Allow dates to be represented as strings in output schemas\n  if (isZodDate(ctx.zodSchema)) {\n    ctx.jsonSchema.type = 'string';\n    ctx.jsonSchema.format = 'date-time';\n  }\n\n  if (isZodUndefined(ctx.zodSchema)) {\n    ctx.jsonSchema.type = 'null';\n  }\n};\n\nconst zodJSONSchemaTarget = 'draft-2020-12' as const;\n\nexport const zodSchemaToJson: (\n  zodSchema: $ZodType,\n  registry: $ZodRegistry<{ id?: string }>,\n  io: 'input' | 'output',\n  openAPISchemaVersion: OpenAPISchemaVersion,\n) => JSONSchema.BaseSchema = (\n  zodSchema,\n  registry,\n  io,\n  openAPISchemaVersion,\n) => {\n  const schemaRegistryEntry = registry.get(zodSchema);\n\n  /**\n   * Checks whether the provided schema is registered in the given registry.\n   * If it is present and has an `id`, it can be referenced as component.\n   *\n   * @see https://github.com/turkerdev/fastify-type-provider-zod/issues/173\n   */\n  if (schemaRegistryEntry?.id) {\n    return { $ref: getReferenceUri(schemaRegistryEntry.id, io) };\n  }\n\n  /**\n   * Unfortunately, at the time of writing, there is no way to generate a schema with `$ref`\n   * using `toJSONSchema` and a zod schema.\n   *\n   * As a workaround, we create a zod registry containing only the specific schema we want to convert.\n   *\n   * @see https://github.com/colinhacks/zod/issues/4281\n   */\n  const tempID = 'GEN';\n  const tempRegistry = new $ZodRegistry<{ id: string }>();\n  tempRegistry.add(zodSchema, { id: tempID });\n\n  const {\n    schemas: { [tempID]: result },\n  } = toJSONSchema(tempRegistry, {\n    target: zodJSONSchemaTarget,\n    metadata: registry,\n    io,\n    unrepresentable: 'any',\n    cycles: 'ref',\n    reused: 'inline',\n\n    /**\n     * The uri option only allows customizing the base path of the `$ref`, and it automatically appends a path to it.\n     * As a workaround, we set a placeholder that looks something like this:\n     *\n     * |       marker          | always added by zod | meta.id |\n     * |__SCHEMA__PLACEHOLDER__|      #/$defs/       | User    |\n     *\n     * @example `__SCHEMA__PLACEHOLDER__#/$defs/User\"`\n     * @example `__SCHEMA__PLACEHOLDER__#/$defs/Group\"`\n     *\n     * @see jsonSchemaReplaceRef\n     * @see https://github.com/colinhacks/zod/issues/4750\n     */\n    uri: () => '__SCHEMA__PLACEHOLDER__',\n\n    override: (ctx) => getOverride(ctx, io, registry),\n  });\n\n  /**\n   * Replace the previous generated placeholders with the final `$ref` value\n   */\n  const jsonSchemaReplaceRef = JSON.stringify(result).replaceAll(\n    /\"__SCHEMA__PLACEHOLDER__#\\/\\$defs\\/(.+?)\"/g,\n    (_, id) => `\"${getReferenceUri(id, io)}\"`,\n  );\n\n  const jsonSchemaWithRef = JSON.parse(jsonSchemaReplaceRef);\n\n  return convertSchemaToOpenAPISchemaVersion(jsonSchemaWithRef, {\n    openAPISchemaVersion,\n  });\n};\n\nexport const zodRegistryToJson: (\n  registry: $ZodRegistry<{ id?: string }>,\n  io: 'input' | 'output',\n  openAPISchemaVersion: OpenAPISchemaVersion,\n) => Record<string, JSONSchema.BaseSchema> = (\n  registry,\n  io,\n  openAPISchemaVersion,\n) => {\n  const result = toJSONSchema(registry, {\n    target: zodJSONSchemaTarget,\n    io,\n    unrepresentable: 'any',\n    cycles: 'ref',\n    reused: 'inline',\n    uri: (id) => getReferenceUri(id, io),\n    override: (ctx) => getOverride(ctx, io, registry),\n  }).schemas;\n\n  const jsonSchemas: Record<string, JSONSchema.BaseSchema> = {};\n\n  for (const id in result) {\n    jsonSchemas[getSchemaId(id, io)] = convertSchemaToOpenAPISchemaVersion(\n      result[id],\n      { openAPISchemaVersion },\n    );\n  }\n\n  return jsonSchemas;\n};\n\nconst refPropertyValueMatch = /^#\\/components\\//;\n\nfunction collectRefs(obj: unknown, refs = new Set<string>()): Set<string> {\n  if (obj && typeof obj === 'object') {\n    for (const [key, value] of Object.entries(obj)) {\n      if (key === '$ref' && typeof value === 'string') {\n        refs.add(value.replace(refPropertyValueMatch, ''));\n      } else {\n        collectRefs(value, refs);\n      }\n    }\n  }\n  return refs;\n}\n\nexport function removeUnusedRefs(\n  spec: JSONSchema.BaseSchema,\n): JSONSchema.BaseSchema {\n  const usedRefs = collectRefs(spec.paths);\n  const components = spec.components as Record<string, unknown>;\n\n  /* c8 ignore next 3, usually open api schema has components schema set as empty object */\n  if (!components) {\n    return spec;\n  }\n\n  for (const section of Object.keys(components)) {\n    const items = components[section] as Record<string, unknown>;\n    if (!items) {\n      continue;\n    }\n\n    for (const key of Object.keys(items)) {\n      if (![...usedRefs].some((r) => r.startsWith(`${section}/${key}`))) {\n        delete items[key];\n      }\n    }\n  }\n\n  return spec;\n}\n"],"names":["$ZodType","$ZodRegistry","toJSONSchema","convertSchemaToOpenAPISchemaVersion"],"mappings":"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"}